// State Management
let uploadedFiles = [];
let currentJobId = null;
let pollInterval = null;

// DOM Elements
const dropzone = document.getElementById('dropzone');
const fileInput = document.getElementById('fileInput');
const fileList = document.getElementById('fileList');
const uploadSection = document.getElementById('uploadSection');
const configSection = document.getElementById('configSection');
const buildingSection = document.getElementById('buildingSection');
const successSection = document.getElementById('successSection');
const errorSection = document.getElementById('errorSection');

// Buttons
const nextToConfig = document.getElementById('nextToConfig');
const backToUpload = document.getElementById('backToUpload');
const configForm = document.getElementById('configForm');
const tryAgain = document.getElementById('tryAgain');
const createAnother = document.getElementById('createAnother');
const downloadBtn = document.getElementById('downloadBtn');

// Steps
const steps = document.querySelectorAll('.step');

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    setupEventListeners();
});

function setupEventListeners() {
    // Dropzone events
    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('dragover', handleDragOver);
    dropzone.addEventListener('dragleave', handleDragLeave);
    dropzone.addEventListener('drop', handleDrop);

    // File input
    fileInput.addEventListener('change', handleFileSelect);

    // Navigation
    nextToConfig.addEventListener('click', showConfigSection);
    backToUpload.addEventListener('click', showUploadSection);

    // Form submission
    configForm.addEventListener('submit', handleFormSubmit);

    // Icon preview
    document.getElementById('appIcon').addEventListener('change', handleIconPreview);

    // Retry/Reset
    tryAgain.addEventListener('click', resetConverter);
    createAnother.addEventListener('click', resetConverter);

    // Auto-generate package name from app name
    document.getElementById('appName').addEventListener('input', (e) => {
        const appName = e.target.value;
        const packageNameInput = document.getElementById('packageName');
        if (!packageNameInput.value || packageNameInput.dataset.autoGenerated === 'true') {
            const sanitized = appName.toLowerCase().replace(/[^a-z0-9]/g, '');
            packageNameInput.value = `com.brelinx.${sanitized}`;
            packageNameInput.dataset.autoGenerated = 'true';
        }
    });

    document.getElementById('packageName').addEventListener('input', (e) => {
        e.target.dataset.autoGenerated = 'false';
    });
}

// Drag and Drop Handlers
function handleDragOver(e) {
    e.preventDefault();
    dropzone.classList.add('drag-over');
}

function handleDragLeave(e) {
    e.preventDefault();
    dropzone.classList.remove('drag-over');
}

function handleDrop(e) {
    e.preventDefault();
    dropzone.classList.remove('drag-over');
    const files = Array.from(e.dataTransfer.files);
    addFiles(files);
}

function handleFileSelect(e) {
    const files = Array.from(e.target.files);
    addFiles(files);
}

// File Management
function addFiles(files) {
    const validExtensions = ['.html', '.css', '.js', '.png', '.jpg', '.jpeg', '.svg', '.gif', '.woff', '.woff2', '.ttf', '.otf', '.json'];

    files.forEach(file => {
        const ext = '.' + file.name.split('.').pop().toLowerCase();
        if (validExtensions.includes(ext)) {
            // Check if file already exists
            const exists = uploadedFiles.some(f => f.name === file.name);
            if (!exists) {
                uploadedFiles.push(file);
            }
        }
    });

    renderFileList();
    updateNextButton();
}

function removeFile(index) {
    uploadedFiles.splice(index, 1);
    renderFileList();
    updateNextButton();
}

function renderFileList() {
    if (uploadedFiles.length === 0) {
        fileList.classList.remove('has-files');
        fileList.innerHTML = '';
        return;
    }

    fileList.classList.add('has-files');
    fileList.innerHTML = uploadedFiles.map((file, index) => `
        <div class="file-item">
            <div class="file-info">
                <div class="file-icon">${getFileIcon(file.name)}</div>
                <div class="file-details">
                    <div class="file-name">${file.name}</div>
                    <div class="file-size">${formatFileSize(file.size)}</div>
                </div>
            </div>
            <button class="file-remove" onclick="removeFile(${index})">
                <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                    <path d="M6 6L14 14M6 14L14 6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button>
        </div>
    `).join('');
}

function getFileIcon(filename) {
    const ext = filename.split('.').pop().toLowerCase();
    const icons = {
        'html': 'HTML',
        'css': 'CSS',
        'js': 'JS',
        'png': 'IMG',
        'jpg': 'IMG',
        'jpeg': 'IMG',
        'svg': 'SVG',
        'gif': 'GIF',
        'woff': 'FONT',
        'woff2': 'FONT',
        'ttf': 'FONT',
        'otf': 'FONT',
        'json': 'JSON'
    };
    return icons[ext] || 'FILE';
}

function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}

function updateNextButton() {
    const hasHtml = uploadedFiles.some(f => f.name.endsWith('.html'));
    nextToConfig.disabled = !hasHtml;
}

// Icon Preview
function handleIconPreview(e) {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            const preview = document.getElementById('iconPreview');
            preview.innerHTML = `<img src="${e.target.result}" alt="App Icon">`;
        };
        reader.readAsDataURL(file);
    }
}

// Navigation
function showConfigSection() {
    uploadSection.classList.add('hidden');
    configSection.classList.remove('hidden');
    updateSteps(2);
}

function showUploadSection() {
    configSection.classList.add('hidden');
    uploadSection.classList.remove('hidden');
    updateSteps(1);
}

function updateSteps(activeStep) {
    steps.forEach((step, index) => {
        const stepNum = index + 1;
        step.classList.remove('active', 'completed');
        if (stepNum === activeStep) {
            step.classList.add('active');
        } else if (stepNum < activeStep) {
            step.classList.add('completed');
        }
    });
}

// Form Submission
async function handleFormSubmit(e) {
    e.preventDefault();

    const formData = new FormData();

    // Add web files
    uploadedFiles.forEach(file => {
        formData.append('files', file);
    });

    // Add app icon if provided
    const iconFile = document.getElementById('appIcon').files[0];
    if (iconFile) {
        formData.append('icon', iconFile);
    }

    // Add configuration
    const config = {
        appName: document.getElementById('appName').value,
        packageName: document.getElementById('packageName').value,
        versionName: document.getElementById('versionName').value,
        versionCode: document.getElementById('versionCode').value
    };

    formData.append('config', JSON.stringify(config));

    // Show building section
    configSection.classList.add('hidden');
    buildingSection.classList.remove('hidden');
    updateSteps(3);

    try {
        // Upload and build
        const response = await fetch(`${API_BASE_URL}/build`, {
            method: 'POST',
            body: formData
        });

        if (!response.ok) {
            throw new Error('Build request failed');
        }

        const data = await response.json();
        currentJobId = data.jobId;

        // Start polling for status
        startPolling();

    } catch (error) {
        console.error('Build error:', error);
        showError(error.message || 'Failed to start build process. Please try again.');
    }
}

// Polling
function startPolling() {
    let progress = 0;

    pollInterval = setInterval(async () => {
        try {
            const response = await fetch(`${API_BASE_URL}/status/${currentJobId}`);

            if (!response.ok) {
                throw new Error('Failed to get build status');
            }

            const data = await response.json();

            // Update progress
            updateBuildProgress(data.status, data.progress || progress);
            progress = data.progress || progress;

            if (data.status === 'completed') {
                clearInterval(pollInterval);
                showSuccess(data.apkUrl);
            } else if (data.status === 'failed') {
                clearInterval(pollInterval);
                showError(data.error || 'Build failed. Please try again.');
            } else {
                // Increment progress for visual feedback
                if (progress < 90) {
                    progress += 5;
                }
            }

        } catch (error) {
            console.error('Polling error:', error);
            clearInterval(pollInterval);
            showError('Lost connection to server. Please try again.');
        }
    }, 2000); // Poll every 2 seconds
}

function updateBuildProgress(status, progress) {
    const statusMessages = {
        'queued': 'Waiting in queue...',
        'processing': 'Processing your files...',
        'building': 'Building Android app...',
        'signing': 'Signing APK...',
        'completed': 'Build completed!'
    };

    document.getElementById('buildStatus').textContent = statusMessages[status] || 'Building...';
    document.getElementById('progressFill').style.width = `${progress}%`;
    document.getElementById('progressText').textContent = `${Math.round(progress)}%`;
}

// Success/Error Handlers
function showSuccess(apkUrl) {
    buildingSection.classList.add('hidden');
    successSection.classList.remove('hidden');

    downloadBtn.href = `${API_BASE_URL.replace('/api', '')}${apkUrl}`;
    downloadBtn.download = `${document.getElementById('appName').value.replace(/\s+/g, '_')}.apk`;
}

function showError(message) {
    buildingSection.classList.add('hidden');
    errorSection.classList.remove('hidden');

    document.getElementById('errorMessage').textContent = message;
}

function resetConverter() {
    // Reset state
    uploadedFiles = [];
    currentJobId = null;
    if (pollInterval) {
        clearInterval(pollInterval);
        pollInterval = null;
    }

    // Reset UI
    fileInput.value = '';
    configForm.reset();
    document.getElementById('iconPreview').innerHTML = `
        <svg width="48" height="48" viewBox="0 0 48 48" fill="none">
            <path d="M24 12V28M24 12L18 18M24 12L30 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M12 28V32C12 34.2091 13.7909 36 16 36H32C34.2091 36 36 34.2091 36 32V28" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        </svg>
        <span>Upload Icon</span>
    `;

    // Show upload section
    successSection.classList.add('hidden');
    errorSection.classList.add('hidden');
    buildingSection.classList.add('hidden');
    configSection.classList.add('hidden');
    uploadSection.classList.remove('hidden');

    renderFileList();
    updateNextButton();
    updateSteps(1);

    // Scroll to top
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

// Make removeFile available globally
window.removeFile = removeFile;

// Smooth scroll for anchor links
document.querySelectorAll('a[href^="#"]').forEach(anchor => {
    anchor.addEventListener('click', function (e) {
        const href = this.getAttribute('href');
        if (href !== '#' && document.querySelector(href)) {
            e.preventDefault();
            document.querySelector(href).scrollIntoView({
                behavior: 'smooth'
            });
        }
    });
});
